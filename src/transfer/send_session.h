#pragma once

#include "file_hasher.hpp"
#include "models/dto/file_dto.h"
#include "models/dto/request_send_dto.h"
#include "models/dto/send_chunk_dto.h"
#include "models/dto/verify_integrity_dto.h"
#include "utils/binary_message.h"
#include <boost/asio.hpp>
#include <constants/transfer.h>
#include <models/session_status.h>
#include <models/transfer_file_info.h>
#include <network/http_client.h>
#include <security/certificate_manager.h>
#include <string>
#include <unordered_map>

namespace lansend {

using SessionStartedCallback = std::function<void()>;
using SessionCleanupCallback = std::function<void()>;

using NotificationCallback = std::function<void(const nlohmann::json& message)>;

class SendSession {
public:
    SendSession(boost::asio::io_context& ioc, CertificateManager& cert_manager);
    ~SendSession() = default;

    SendSession(const SendSession&) = delete;
    SendSession& operator=(const SendSession&) = delete;

    SessionStatus session_status() const { return session_status_; }

    std::string session_id() const { return session_id_; }

    void Cancel();

    bool IsCancelled() const;

    boost::asio::awaitable<void> Start(const std::vector<std::filesystem::path>& file_paths,
                                       std::string_view host,
                                       unsigned int port,
                                       SessionStartedCallback callback = nullptr);

private:
    boost::asio::awaitable<bool> requestSend(const RequestSendDto& dto);
    boost::asio::awaitable<void> sendFile(std::string_view file_id);
    boost::asio::awaitable<bool> sendChunk(const SendChunkDto& dto, const BinaryData& chunk_data);
    boost::asio::awaitable<bool> verifyIntegrity(const VerifyIntegrityDto& dto);
    boost::asio::awaitable<bool> cancelSend();

    std::vector<FileDto> prepareFiles(const std::vector<std::filesystem::path>& file_paths);

    boost::asio::io_context& ioc_;
    CertificateManager& cert_manager_;
    HttpsClient client_;

    FileHasher file_hasher_;

    std::unordered_map<std::string, TransferFileInfo> transfer_files_;
    SessionStatus session_status_ = SessionStatus::kIdle;

    std::string session_id_ = {}; // Generated by the server
};

} // namespace lansend